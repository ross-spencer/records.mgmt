"""Self-contained ID generation system, i.e. for creating unique
identifiers for groups of items, e.g. digital records.

The system creates its own log and writes out to it the information
needed to generate unique identifiers and ensure there are no duplicates.

An __init__.py file is written so that one always exists and ensures the
module functionality of this script works.

The design of the UID is as such:

   "UNA:02.2023/0030E149E486"
   "{PREFIX}.{DATE.TODAY.DAY}.{DATE.TODAY.MONTH}/00{UID}"

The UID is a hex token generated by the Python secrets library. It is a
5-byte/10-digit number which can represent: 0 to 1,099,511,627,775
values -- 16*16*16*16*16*16*16*16*16*16.

There should be a low-probability of duplicates. The inclusion of month
and year in the identifier means there are a massive number of potential
IDs in a single month. The UIDs themselves should be fairly
self-contained and entirely disposable.

With the exception of month and year, sequencing information is left out
of the identifier's design. Sequences can tell us a lot and they can
also be viewed as overly precious.
"""

import json
import secrets
from datetime import date, datetime
from typing import Final

from fastapi import FastAPI
from fastapi.responses import RedirectResponse

prefix: Final[str] = "UNA"

# Create files in support of this application. To be self-contained, the
# app needs to create the log file for storing IDs and __init__.py file
# to be able to access them as a Python variable.
try:
    from log import ids
except (ModuleNotFoundError, ImportError):
    ids = {}
    pass


def _get_date(override: bool = False, timestamp: int = 0) -> datetime:
    """Return today's date."""
    if not override:
        return date.today()
    return date.fromtimestamp(timestamp)


logs_docstring: Final[
    str
] = '''"""Identifiers generated by this module.

   ids[dict] = {id[str]: attempts_to_generate[int]}
"""\n\n
'''


def _write_log_and_init(ids: dict) -> None:
    """Write our UID to a log and ensure our external module files exist."""
    init_name: Final[str] = "__init__.py"
    log_name: Final[str] = "log.py"
    with open(init_name, "w") as init:
        init.write("")
    with open(log_name, "w") as id_log:
        id_log.write(f"{logs_docstring}")
        id_log.write(f"ids = {json.dumps(ids, indent=3)}\n")


def _create_uid() -> str:
    """Create a unique ID to be used in apps outside of this one."""
    for attempt in range(100):
        id_ = secrets.token_hex(5).upper()
        if id_ not in ids:
            break
        if id_ in ids:
            raise ValueError("Call the generation function again to create an ID")
    today = _get_date()
    archive_id = f"{prefix}:{today.month:02d}.{today.year}/00{id_}"
    ids[archive_id] = attempt
    _write_log_and_init(ids)
    return archive_id


# API description.
API_DESCRIPTION: Final[
    str
] = """
## Records management API

Archives, records, and information management helper functions.

Functions are currently separated into:
* Standard: functions for everyday use.
* Maintenance: functions that help with maintaining this service and
your efforts.
"""

# OpenAPI tags delineating the documentation.
TAG_STANDARD: Final[str] = "standard"
TAG_MAINTENANCE: Final[str] = "maintenance"

# Metadata for each of the tags in the OpenAPI specification. To order
# their display on the page, order the tags in this block.
tags_metadata = [
    {
        "name": TAG_STANDARD,
        "description": "Day to day functions required for information records management",
    },
    {
        "name": TAG_MAINTENANCE,
        "description": "Functions associated with maintenance of the service",
    },
]

app = FastAPI(
    title="records.mgmt",
    description=API_DESCRIPTION,
    version="2023.02.21.0001",
    contact={
        "Ross Spencer": "ross@example.com",
    },
    openapi_tags=tags_metadata,
)


@app.get("/", include_in_schema=False)
def redirect_root_to_docs() -> RedirectResponse:
    """Redirect a user calling the API root '/' to the OpenAPI
    documentation.
    """
    return RedirectResponse(url="/docs")


@app.get("/uid", tags=[TAG_STANDARD])
async def uid() -> dict:
    """Create a new UID for use in your records and records management
    processes.
    """
    return {"message": _create_uid()}


@app.get("/uids", tags=[TAG_MAINTENANCE])
async def uids() -> dict:
    """Return all UIDs minted by this service."""
    return ids
